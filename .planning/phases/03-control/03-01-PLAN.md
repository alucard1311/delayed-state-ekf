---
phase: 03-control
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/auv_control/package.xml, src/auv_control/CMakeLists.txt, src/auv_control/include/auv_control/pid.hpp, src/auv_control/include/auv_control/control_node.hpp, src/auv_control/src/pid.cpp, src/auv_control/src/control_node.cpp, src/auv_control/src/main.cpp]
autonomous: true

must_haves:
  truths:
    - "Control package compiles without errors"
    - "PID class computes proportional, integral, derivative terms"
    - "Control node subscribes to EKF pose"
  artifacts:
    - path: "src/auv_control/include/auv_control/pid.hpp"
      provides: "Generic PID controller class"
      contains: "class PID"
    - path: "src/auv_control/src/control_node.cpp"
      provides: "ROS2 control node skeleton"
      contains: "ekfCallback"
  key_links:
    - from: "control_node.cpp"
      to: "/auv/ekf/pose"
      via: "ROS2 subscriber"
      pattern: "create_subscription.*Odometry"
---

<objective>
Create C++ control package with generic PID class and control node skeleton.

Purpose: Foundation for AUV controllers - establishes reusable PID class and ROS2 node structure that subsequent plans will extend with specific controllers.
Output: Compilable ROS2 C++ package with PID class and control node subscribing to EKF pose.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-navigation/02-04-SUMMARY.md

**EKF output (from Phase 2):**
- Topic: `/auv/ekf/pose` (nav_msgs/msg/Odometry) @ 50Hz
- Contains: position (x,y,z), orientation (quaternion), velocity (linear, angular)

**Thruster topics (from auv.xml):**
- `/auv/thruster/surge` - main propulsion, ±100 N
- `/auv/thruster/sway` - lateral, ±50 N
- `/auv/thruster/heave` - vertical, ±50 N
- `/auv/thruster/yaw_bow` - yaw at bow, ±30 N
- `/auv/thruster/yaw_stern` - yaw at stern, ±30 N (inverted)

**Setpoint topics (to be created):**
- `/auv/cmd/depth` - target depth in meters
- `/auv/cmd/heading` - target heading in radians
- `/auv/cmd/velocity` - target forward velocity in m/s
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ROS2 C++ package structure</name>
  <files>src/auv_control/package.xml, src/auv_control/CMakeLists.txt</files>
  <action>
Create src/auv_control/ package:

1. package.xml:
   - Package name: auv_control
   - Build type: ament_cmake
   - Dependencies: rclcpp, std_msgs, geometry_msgs, nav_msgs

2. CMakeLists.txt:
   - Minimum cmake 3.8
   - C++17 standard
   - find_package for ament_cmake, rclcpp, std_msgs, geometry_msgs, nav_msgs
   - Create library target: auv_control_lib from src/pid.cpp, src/control_node.cpp
   - Create executable: control_node from src/main.cpp linking auv_control_lib
   - Include directories: include/
   - Install targets and include directories
   - ament_package()

Create directories: include/auv_control/, src/
  </action>
  <verify>Package structure exists with package.xml and CMakeLists.txt</verify>
  <done>Valid ROS2 C++ package structure created</done>
</task>

<task type="auto">
  <name>Task 2: Implement generic PID controller class</name>
  <files>src/auv_control/include/auv_control/pid.hpp, src/auv_control/src/pid.cpp</files>
  <action>
Create PID class with anti-windup:

pid.hpp:
```cpp
#ifndef AUV_CONTROL__PID_HPP_
#define AUV_CONTROL__PID_HPP_

namespace auv_control {

class PID {
public:
  PID(double kp, double ki, double kd, double max_output, double max_integral);

  // Compute control output given error and dt
  double compute(double error, double dt);

  // Reset integral term (call on setpoint change or large error)
  void reset();

  // Update gains at runtime
  void setGains(double kp, double ki, double kd);

private:
  double kp_, ki_, kd_;
  double max_output_;
  double max_integral_;
  double integral_;
  double prev_error_;
  bool first_run_;
};

}  // namespace auv_control

#endif  // AUV_CONTROL__PID_HPP_
```

pid.cpp:
1. Constructor initializes gains and limits, sets integral_ = 0, first_run_ = true
2. compute():
   - P term: kp_ * error
   - I term: integral_ += ki_ * error * dt, clamp to [-max_integral_, max_integral_]
   - D term: kd_ * (error - prev_error_) / dt (skip on first run)
   - Output: P + I + D, clamp to [-max_output_, max_output_]
   - Update prev_error_ and first_run_
3. reset(): integral_ = 0, first_run_ = true
4. setGains(): update kp_, ki_, kd_

Important: Handle dt = 0 case (return 0). Handle first run for D term (skip derivative).
  </action>
  <verify>Header compiles (checked when building package)</verify>
  <done>Generic PID class with anti-windup and output limiting</done>
</task>

<task type="auto">
  <name>Task 3: Implement control node skeleton</name>
  <files>src/auv_control/include/auv_control/control_node.hpp, src/auv_control/src/control_node.cpp, src/auv_control/src/main.cpp</files>
  <action>
Create control node with EKF subscriber and thruster publishers:

control_node.hpp:
```cpp
#ifndef AUV_CONTROL__CONTROL_NODE_HPP_
#define AUV_CONTROL__CONTROL_NODE_HPP_

#include <rclcpp/rclcpp.hpp>
#include <nav_msgs/msg/odometry.hpp>
#include <std_msgs/msg/float64.hpp>
#include "auv_control/pid.hpp"

namespace auv_control {

class ControlNode : public rclcpp::Node {
public:
  ControlNode();

private:
  // EKF state subscriber
  rclcpp::Subscription<nav_msgs::msg::Odometry>::SharedPtr ekf_sub_;

  // Setpoint subscribers (for external commands)
  rclcpp::Subscription<std_msgs::msg::Float64>::SharedPtr depth_cmd_sub_;
  rclcpp::Subscription<std_msgs::msg::Float64>::SharedPtr heading_cmd_sub_;
  rclcpp::Subscription<std_msgs::msg::Float64>::SharedPtr velocity_cmd_sub_;

  // Thruster publishers
  rclcpp::Publisher<std_msgs::msg::Float64>::SharedPtr surge_pub_;
  rclcpp::Publisher<std_msgs::msg::Float64>::SharedPtr sway_pub_;
  rclcpp::Publisher<std_msgs::msg::Float64>::SharedPtr heave_pub_;
  rclcpp::Publisher<std_msgs::msg::Float64>::SharedPtr yaw_bow_pub_;
  rclcpp::Publisher<std_msgs::msg::Float64>::SharedPtr yaw_stern_pub_;

  // Control timer
  rclcpp::TimerBase::SharedPtr control_timer_;

  // Current state from EKF
  double current_depth_;
  double current_heading_;
  double current_velocity_;
  rclcpp::Time last_ekf_time_;
  bool ekf_received_;

  // Setpoints
  double target_depth_;
  double target_heading_;
  double target_velocity_;

  // Callbacks
  void ekfCallback(const nav_msgs::msg::Odometry::SharedPtr msg);
  void depthCmdCallback(const std_msgs::msg::Float64::SharedPtr msg);
  void headingCmdCallback(const std_msgs::msg::Float64::SharedPtr msg);
  void velocityCmdCallback(const std_msgs::msg::Float64::SharedPtr msg);
  void controlLoop();

  // Helper to extract yaw from quaternion
  double quaternionToYaw(double x, double y, double z, double w);
};

}  // namespace auv_control

#endif  // AUV_CONTROL__CONTROL_NODE_HPP_
```

control_node.cpp:
1. Constructor:
   - Create subscribers for EKF pose and setpoint commands
   - Create publishers for all 5 thruster topics
   - Create control timer at 50Hz calling controlLoop()
   - Initialize all state variables to 0
   - Initialize ekf_received_ = false

2. ekfCallback():
   - Extract depth from pose.pose.position.z
   - Extract heading (yaw) from pose.pose.orientation using quaternionToYaw()
   - Extract velocity from twist.twist.linear.x
   - Update last_ekf_time_, set ekf_received_ = true

3. Setpoint callbacks: update target_depth_, target_heading_, target_velocity_

4. controlLoop(): (STUB for now - implemented in Plan 03-02)
   - If !ekf_received_, return early (no state yet)
   - Log state periodically for debugging
   - (Controllers will be added in next plan)

5. quaternionToYaw(): standard quaternion to yaw conversion

main.cpp:
```cpp
#include <rclcpp/rclcpp.hpp>
#include "auv_control/control_node.hpp"

int main(int argc, char** argv) {
  rclcpp::init(argc, argv);
  auto node = std::make_shared<auv_control::ControlNode>();
  rclcpp::spin(node);
  rclcpp::shutdown();
  return 0;
}
```

Important: The controlLoop() is a stub - it will be filled in by Plan 03-02.
  </action>
  <verify>colcon build --packages-select auv_control compiles without errors</verify>
  <done>Control node skeleton with EKF subscriber and thruster publishers</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] colcon build --packages-select auv_control succeeds
- [ ] No compiler warnings (treat warnings as errors if possible)
- [ ] Package has proper ROS2 structure
</verification>

<success_criteria>
- All tasks completed
- Control package compiles with C++17
- PID class has P, I, D terms with anti-windup
- Control node subscribes to EKF and has thruster publishers
- Package structure follows ROS2 conventions
</success_criteria>

<output>
After completion, create `.planning/phases/03-control/03-01-SUMMARY.md`
</output>
