---
phase: 02-navigation
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified: [src/auv_ekf/include/auv_ekf/ekf_node.hpp, src/auv_ekf/src/ekf_node.cpp, src/auv_ekf/package.xml, src/auv_ekf/CMakeLists.txt]
autonomous: true

must_haves:
  truths:
    - "EKF subscribes to DVL topic and updates velocity/position"
    - "EKF continues prediction when sensors drop out (dead reckoning)"
    - "EKF publishes filtered pose at consistent rate"
  artifacts:
    - path: "src/auv_ekf/src/ekf_node.cpp"
      provides: "DVL measurement update and dead reckoning"
      contains: "dvlCallback"
  key_links:
    - from: "ekf_node.cpp"
      to: "/auv/dvl"
      via: "ROS2 subscriber callback"
      pattern: "stonefish_ros2::msg::DVL"
    - from: "ekf_node.cpp"
      to: "/auv/ekf/pose"
      via: "ROS2 publisher"
      pattern: "nav_msgs::msg::Odometry"
---

<objective>
Add DVL velocity measurement update and dead reckoning fallback.

Purpose: Complete sensor fusion with DVL for velocity/position and ensure graceful degradation - satisfies NAV-01, NAV-04, NAV-05.
Output: EKF that fuses all sensors and maintains estimates during sensor dropouts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-navigation/02-01-SUMMARY.md
@.planning/phases/02-navigation/02-02-SUMMARY.md

**DVL topic:**
- DVL @ 10Hz â†’ `/auv/dvl` (stonefish_ros2/msg/DVL)
- Contains velocity in body frame and altitude to bottom

**stonefish_ros2::msg::DVL fields:**
- header (std_msgs/Header)
- velocity (geometry_msgs/Vector3) - velocity in body frame
- altitude (float64) - distance to seabed

**Dead reckoning requirements (NAV-05):**
- If no sensor updates for > timeout, continue with prediction only
- Log warning when in dead reckoning mode
- Track time since last measurement for each sensor
- Increase process noise during dead reckoning (optional enhancement)

**Position integration from DVL:**
DVL gives body-frame velocity. To update NED position:
1. Get body velocity [vx, vy, vz]
2. Rotate to NED frame using current orientation
3. Integrate: position_ned += velocity_ned * dt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DVL subscriber and velocity measurement update</name>
  <files>src/auv_ekf/include/auv_ekf/ekf_node.hpp, src/auv_ekf/src/ekf_node.cpp, src/auv_ekf/package.xml, src/auv_ekf/CMakeLists.txt</files>
  <action>
Update package.xml to add:
- depend on stonefish_ros2 (for DVL message type)

Update CMakeLists.txt to add:
- find_package(stonefish_ros2 REQUIRED)
- Add stonefish_ros2 to target dependencies

Update header to add:
- Include stonefish_ros2/msg/dvl.hpp
- DVL subscriber declaration
- DVL measurement noise R_dvl (3x3 for vx, vy, vz)
- dvlCallback() method declaration
- last_dvl_time_ for dead reckoning tracking

Update cpp to implement:

1. In constructor:
   - Create subscriber to "/auv/dvl" with dvlCallback
   - Initialize R_dvl (3x3 diagonal) with noise ~0.01 m/s per axis
   - Initialize last_dvl_time_ to current time

2. dvlCallback(stonefish_ros2::msg::DVL::SharedPtr msg):
   - Extract velocity from msg->velocity (body frame)
   - Create measurement vector z (3x1): [vx, vy, vz]
   - Create measurement matrix H (3x12): maps state velocity to measurement
     * H selects states [VX, VY, VZ]
   - Call measurementUpdate(z, H, R_dvl)
   - Update last_dvl_time_

3. Position integration in predict():
   - Get body velocity from state [VX, VY, VZ]
   - Get orientation from state [ROLL, PITCH, YAW]
   - Build rotation matrix R = eulerToRotationMatrix(roll, pitch, yaw)
   - Transform to NED: velocity_ned = R * velocity_body
   - Update position: state_[X] += velocity_ned[0] * dt
   - Update position: state_[Y] += velocity_ned[1] * dt
   - (Z is already updated by pressure sensor directly)

Important: DVL velocity is in body frame, must rotate to NED for position integration.
  </action>
  <verify>colcon build --packages-select auv_ekf compiles without errors</verify>
  <done>DVL callback updates velocity states, position integrates from velocity</done>
</task>

<task type="auto">
  <name>Task 2: Implement dead reckoning fallback</name>
  <files>src/auv_ekf/include/auv_ekf/ekf_node.hpp, src/auv_ekf/src/ekf_node.cpp</files>
  <action>
Update header to add:
- last_imu_time_, last_pressure_time_ declarations
- SENSOR_TIMEOUT constant (e.g., 1.0 second)
- dead_reckoning_mode_ flag
- checkSensorHealth() method

Update cpp to implement:

1. Add constant:
   ```cpp
   constexpr double SENSOR_TIMEOUT = 1.0;  // seconds
   ```

2. In constructor:
   - Initialize last_imu_time_, last_pressure_time_, last_dvl_time_
   - Initialize dead_reckoning_mode_ = false

3. Update sensor callbacks to record timestamp:
   - imuCallback: last_imu_time_ = this->now()
   - pressureCallback: last_pressure_time_ = this->now()
   - dvlCallback: last_dvl_time_ = this->now()

4. checkSensorHealth() - call at start of predict():
   ```cpp
   void EkfNode::checkSensorHealth() {
     auto now = this->now();
     bool imu_ok = (now - last_imu_time_).seconds() < SENSOR_TIMEOUT;
     bool pressure_ok = (now - last_pressure_time_).seconds() < SENSOR_TIMEOUT;
     bool dvl_ok = (now - last_dvl_time_).seconds() < SENSOR_TIMEOUT;

     bool was_dead_reckoning = dead_reckoning_mode_;
     dead_reckoning_mode_ = !imu_ok || !pressure_ok || !dvl_ok;

     if (dead_reckoning_mode_ && !was_dead_reckoning) {
       RCLCPP_WARN(this->get_logger(), "Entering dead reckoning mode - sensors: IMU=%s, Pressure=%s, DVL=%s",
                   imu_ok ? "OK" : "TIMEOUT", pressure_ok ? "OK" : "TIMEOUT", dvl_ok ? "OK" : "TIMEOUT");
     } else if (!dead_reckoning_mode_ && was_dead_reckoning) {
       RCLCPP_INFO(this->get_logger(), "Exiting dead reckoning mode - all sensors OK");
     }
   }
   ```

5. In predict():
   - Call checkSensorHealth() at start
   - Optionally increase process noise Q during dead reckoning (2x multiplier)

6. In publishState():
   - Add dead_reckoning indicator to message (use pose_covariance or custom field)
   - Log state periodically for debugging

This ensures EKF continues operating even when sensors fail temporarily.
  </action>
  <verify>colcon build --packages-select auv_ekf compiles without errors</verify>
  <done>Dead reckoning mode activates when sensors timeout, logs warnings</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] colcon build --packages-select auv_ekf succeeds
- [ ] DVL subscriber created and callback implemented
- [ ] Position integration uses rotated velocity
- [ ] Dead reckoning mode tracked and logged
</verification>

<success_criteria>
- All tasks completed
- EKF subscribes to /auv/dvl and updates velocity
- Position integrates from body-frame velocity
- Dead reckoning mode activates on sensor timeout
- Warnings logged when entering/exiting dead reckoning
</success_criteria>

<output>
After completion, create `.planning/phases/02-navigation/02-03-SUMMARY.md`
</output>
