---
phase: 02-navigation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/auv_ekf/package.xml, src/auv_ekf/CMakeLists.txt, src/auv_ekf/include/auv_ekf/ekf_node.hpp, src/auv_ekf/src/ekf_node.cpp, src/auv_ekf/src/main.cpp]
autonomous: true

must_haves:
  truths:
    - "EKF node compiles without errors"
    - "EKF node launches and initializes state vector"
    - "Prediction step runs at configured rate"
  artifacts:
    - path: "src/auv_ekf/include/auv_ekf/ekf_node.hpp"
      provides: "EKF class declaration with state vector and covariance"
      contains: "Eigen::VectorXd"
    - path: "src/auv_ekf/src/ekf_node.cpp"
      provides: "EKF prediction implementation"
      contains: "predict"
  key_links:
    - from: "ekf_node.cpp"
      to: "rclcpp"
      via: "ROS2 node inheritance"
      pattern: "rclcpp::Node"
---

<objective>
Create C++ EKF ROS2 node with state vector and prediction model.

Purpose: Foundation for sensor fusion - establishes the EKF structure that subsequent plans will extend with measurement updates.
Output: Compilable ROS2 C++ package with EKF node that runs prediction at 50Hz.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure/01-02-SUMMARY.md

**Sensor topics from Phase 1:**
- IMU @ 100Hz → `/auv/imu` (sensor_msgs/msg/Imu)
- DVL @ 10Hz → `/auv/dvl` (stonefish_ros2/msg/DVL)
- Pressure @ 10Hz → `/auv/pressure` (sensor_msgs/msg/FluidPressure)
- Odometry @ 50Hz → `/auv/odometry` (ground truth for validation)

**EKF State Vector (12 states):**
- Position: [x, y, z] in NED frame
- Velocity: [vx, vy, vz] body frame
- Orientation: [roll, pitch, yaw] Euler angles
- Angular velocity: [wx, wy, wz] body frame

**Key design decisions:**
- Use Eigen for linear algebra (standard in ROS2 C++)
- 50Hz prediction rate (faster than slowest sensor)
- NED frame convention (standard for underwater)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ROS2 C++ package structure</name>
  <files>src/auv_ekf/package.xml, src/auv_ekf/CMakeLists.txt</files>
  <action>
Create src/auv_ekf/ package:

1. package.xml:
   - Package name: auv_ekf
   - Build type: ament_cmake
   - Dependencies: rclcpp, std_msgs, sensor_msgs, geometry_msgs, nav_msgs, tf2, tf2_ros, Eigen3
   - exec_depend on stonefish_ros2 (for DVL message type)

2. CMakeLists.txt:
   - Minimum cmake 3.8
   - C++17 standard
   - find_package for ament_cmake, rclcpp, sensor_msgs, geometry_msgs, nav_msgs, tf2, tf2_ros, Eigen3, stonefish_ros2
   - Create library target: auv_ekf_lib from src/ekf_node.cpp
   - Create executable: ekf_node from src/main.cpp linking auv_ekf_lib
   - Include directories: include/
   - Install targets and include directories
   - ament_package()

Create directories: include/auv_ekf/, src/
  </action>
  <verify>Package structure exists with package.xml and CMakeLists.txt</verify>
  <done>Valid ROS2 C++ package structure created</done>
</task>

<task type="auto">
  <name>Task 2: Implement EKF node header</name>
  <files>src/auv_ekf/include/auv_ekf/ekf_node.hpp</files>
  <action>
Create EKF node class declaration:

```cpp
#ifndef AUV_EKF__EKF_NODE_HPP_
#define AUV_EKF__EKF_NODE_HPP_

#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/imu.hpp>
#include <sensor_msgs/msg/fluid_pressure.hpp>
#include <nav_msgs/msg/odometry.hpp>
#include <Eigen/Dense>

namespace auv_ekf {

class EkfNode : public rclcpp::Node {
public:
  EkfNode();

private:
  // State vector: [x, y, z, vx, vy, vz, roll, pitch, yaw, wx, wy, wz]
  static constexpr int STATE_SIZE = 12;

  // State indices
  enum StateIdx {
    X = 0, Y = 1, Z = 2,
    VX = 3, VY = 4, VZ = 5,
    ROLL = 6, PITCH = 7, YAW = 8,
    WX = 9, WY = 10, WZ = 11
  };

  // EKF state
  Eigen::VectorXd state_;           // 12x1 state vector
  Eigen::MatrixXd covariance_;      // 12x12 covariance matrix
  Eigen::MatrixXd process_noise_;   // 12x12 process noise Q

  // Timing
  rclcpp::Time last_predict_time_;
  bool initialized_;

  // Timer for prediction
  rclcpp::TimerBase::SharedPtr predict_timer_;

  // Publisher for state estimate
  rclcpp::Publisher<nav_msgs::msg::Odometry>::SharedPtr pose_pub_;

  // Methods
  void initializeState();
  void predict();
  void publishState();

  // Helper: rotation matrix from Euler angles
  Eigen::Matrix3d eulerToRotationMatrix(double roll, double pitch, double yaw);
};

}  // namespace auv_ekf

#endif  // AUV_EKF__EKF_NODE_HPP_
```

Key points:
- 12-state vector with clear indices
- Eigen types for matrices
- Prediction timer at 50Hz
- Odometry publisher for pose output
  </action>
  <verify>Header file compiles (checked when building package)</verify>
  <done>EKF node class declared with state vector and methods</done>
</task>

<task type="auto">
  <name>Task 3: Implement EKF prediction and node</name>
  <files>src/auv_ekf/src/ekf_node.cpp, src/auv_ekf/src/main.cpp</files>
  <action>
Create ekf_node.cpp with prediction implementation:

1. Constructor:
   - Initialize state vector to zeros
   - Initialize covariance to identity * initial_uncertainty (declare parameter)
   - Initialize process noise Q (tune later, start with small diagonal values)
   - Create predict_timer at 50Hz calling predict()
   - Create pose_pub_ publishing to "/auv/ekf/pose"
   - Set initialized_ = false

2. initializeState():
   - Set state to zeros (will be updated by first sensor readings)
   - Set reasonable initial covariance (large for position, smaller for velocity)
   - Set initialized_ = true

3. predict():
   - If not initialized, call initializeState() and return
   - Calculate dt from last_predict_time_
   - State transition model (constant velocity):
     * x += vx * dt (in body frame, rotated to NED)
     * y += vy * dt
     * z += vz * dt
     * roll += wx * dt
     * pitch += wy * dt
     * yaw += wz * dt
     * velocities unchanged (constant velocity model)
   - Build Jacobian F (12x12 state transition matrix)
   - Update covariance: P = F * P * F^T + Q
   - Update last_predict_time_
   - Call publishState()

4. publishState():
   - Create nav_msgs::msg::Odometry
   - Set header.stamp and frame_id ("odom")
   - Set child_frame_id ("base_link")
   - Fill pose from state [x, y, z, roll, pitch, yaw]
   - Convert Euler to quaternion for pose.orientation
   - Fill twist from state [vx, vy, vz, wx, wy, wz]
   - Publish

5. eulerToRotationMatrix():
   - Standard ZYX rotation matrix from roll, pitch, yaw

Create main.cpp:
```cpp
#include <rclcpp/rclcpp.hpp>
#include "auv_ekf/ekf_node.hpp"

int main(int argc, char** argv) {
  rclcpp::init(argc, argv);
  auto node = std::make_shared<auv_ekf::EkfNode>();
  rclcpp::spin(node);
  rclcpp::shutdown();
  return 0;
}
```

Important: Use proper Eigen types, avoid dynamic allocation in hot path.
  </action>
  <verify>colcon build --packages-select auv_ekf compiles without errors</verify>
  <done>EKF node builds and runs prediction loop at 50Hz</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] colcon build --packages-select auv_ekf succeeds
- [ ] No compiler warnings (treat warnings as errors if possible)
- [ ] Package has proper ROS2 structure
</verification>

<success_criteria>
- All tasks completed
- EKF node compiles with C++17 and Eigen
- Package structure follows ROS2 conventions
- Prediction model implemented with state transition
</success_criteria>

<output>
After completion, create `.planning/phases/02-navigation/02-01-SUMMARY.md`
</output>
