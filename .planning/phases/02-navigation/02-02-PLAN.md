---
phase: 02-navigation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified: [src/auv_ekf/include/auv_ekf/ekf_node.hpp, src/auv_ekf/src/ekf_node.cpp]
autonomous: true

must_haves:
  truths:
    - "EKF subscribes to IMU topic and updates orientation"
    - "EKF subscribes to pressure topic and updates depth"
    - "State covariance shrinks after measurement updates"
  artifacts:
    - path: "src/auv_ekf/src/ekf_node.cpp"
      provides: "IMU and pressure measurement update functions"
      contains: "imuCallback"
  key_links:
    - from: "ekf_node.cpp"
      to: "/auv/imu"
      via: "ROS2 subscriber callback"
      pattern: "sensor_msgs::msg::Imu"
    - from: "ekf_node.cpp"
      to: "/auv/pressure"
      via: "ROS2 subscriber callback"
      pattern: "sensor_msgs::msg::FluidPressure"
---

<objective>
Add IMU and pressure sensor measurement updates to EKF.

Purpose: Fuse IMU for orientation/angular velocity and pressure for depth - satisfies NAV-02 and NAV-03.
Output: EKF that updates state estimates when IMU and pressure data arrives.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-navigation/02-01-SUMMARY.md

**Sensor topics:**
- IMU @ 100Hz → `/auv/imu` (sensor_msgs/msg/Imu)
  - orientation (quaternion), angular_velocity, linear_acceleration
- Pressure @ 10Hz → `/auv/pressure` (sensor_msgs/msg/FluidPressure)
  - fluid_pressure in Pascals

**Depth calculation from pressure:**
depth = (pressure - atmospheric_pressure) / (water_density * gravity)
- atmospheric_pressure ≈ 101325 Pa
- water_density = 1025 kg/m³ (from auv.xml)
- gravity = 9.81 m/s²

**EKF measurement update (standard form):**
1. Innovation: y = z - H*x (measurement residual)
2. Innovation covariance: S = H*P*H^T + R
3. Kalman gain: K = P*H^T*S^-1
4. State update: x = x + K*y
5. Covariance update: P = (I - K*H)*P
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IMU subscriber and measurement update</name>
  <files>src/auv_ekf/include/auv_ekf/ekf_node.hpp, src/auv_ekf/src/ekf_node.cpp</files>
  <action>
Update header to add:
- IMU subscriber declaration
- IMU measurement noise matrix R_imu (6x6 for orientation + angular velocity)
- imuCallback() method declaration
- Helper: quaternionToEuler() for converting IMU quaternion

Update cpp to implement:

1. In constructor:
   - Create subscriber to "/auv/imu" with imuCallback
   - Initialize R_imu (6x6 diagonal matrix for roll, pitch, yaw, wx, wy, wz)
   - Reasonable values: orientation noise ~0.01 rad, angular velocity noise ~0.01 rad/s

2. imuCallback(sensor_msgs::msg::Imu::SharedPtr msg):
   - Extract orientation quaternion, convert to Euler (roll, pitch, yaw)
   - Extract angular velocity (wx, wy, wz)
   - Create measurement vector z (6x1): [roll, pitch, yaw, wx, wy, wz]
   - Create measurement matrix H (6x12): maps state to measurement
     * H selects states [ROLL, PITCH, YAW, WX, WY, WZ]
   - Call measurementUpdate(z, H, R_imu)

3. measurementUpdate(z, H, R) - generic EKF update:
   - Innovation: y = z - H * state_
   - Wrap angle innovations to [-pi, pi] for orientation states
   - Innovation covariance: S = H * covariance_ * H.transpose() + R
   - Kalman gain: K = covariance_ * H.transpose() * S.inverse()
   - State update: state_ = state_ + K * y
   - Wrap orientation angles to [-pi, pi]
   - Covariance update: covariance_ = (I - K * H) * covariance_

4. quaternionToEuler(x, y, z, w) -> (roll, pitch, yaw):
   - Standard quaternion to Euler conversion
   - Return angles in radians

Important: Handle angle wrapping for yaw discontinuity at ±pi.
  </action>
  <verify>colcon build --packages-select auv_ekf compiles without errors</verify>
  <done>IMU callback updates orientation and angular velocity states</done>
</task>

<task type="auto">
  <name>Task 2: Add pressure subscriber and depth measurement update</name>
  <files>src/auv_ekf/include/auv_ekf/ekf_node.hpp, src/auv_ekf/src/ekf_node.cpp</files>
  <action>
Update header to add:
- Pressure subscriber declaration
- Pressure measurement noise R_pressure (1x1)
- pressureCallback() method declaration
- Constants: ATMOSPHERIC_PRESSURE, WATER_DENSITY, GRAVITY

Update cpp to implement:

1. Add constants at top:
   ```cpp
   constexpr double ATMOSPHERIC_PRESSURE = 101325.0;  // Pa
   constexpr double WATER_DENSITY = 1025.0;  // kg/m³
   constexpr double GRAVITY = 9.81;  // m/s²
   ```

2. In constructor:
   - Create subscriber to "/auv/pressure" with pressureCallback
   - Initialize R_pressure (1x1) with noise ~0.1m depth uncertainty

3. pressureCallback(sensor_msgs::msg::FluidPressure::SharedPtr msg):
   - Extract fluid_pressure
   - Calculate depth: depth = (pressure - ATMOSPHERIC_PRESSURE) / (WATER_DENSITY * GRAVITY)
   - Note: In NED frame, positive Z is DOWN, so depth is positive underwater
   - Create measurement vector z (1x1): [depth]
   - Create measurement matrix H (1x12): H(0, Z) = 1.0, rest zeros
   - Call measurementUpdate(z, H, R_pressure)

4. Verify depth calculation:
   - At surface: pressure ≈ 101325 Pa → depth ≈ 0
   - At 5m: pressure ≈ 101325 + 1025*9.81*5 ≈ 151600 Pa → depth ≈ 5m

Important: Stonefish uses NED convention where Z is positive downward.
  </action>
  <verify>colcon build --packages-select auv_ekf compiles without errors</verify>
  <done>Pressure callback updates depth (Z) state</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] colcon build --packages-select auv_ekf succeeds
- [ ] IMU subscriber created and callback implemented
- [ ] Pressure subscriber created and callback implemented
- [ ] measurementUpdate() function is generic and reusable
</verification>

<success_criteria>
- All tasks completed
- EKF subscribes to /auv/imu and /auv/pressure
- Measurement updates follow standard EKF equations
- Angle wrapping handled correctly
</success_criteria>

<output>
After completion, create `.planning/phases/02-navigation/02-02-SUMMARY.md`
</output>
