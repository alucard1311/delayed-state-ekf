---
phase: 02-navigation
plan: 04
type: execute
wave: 4
depends_on: ["02-03"]
files_modified: [src/auv_ekf/launch/ekf.launch.py, src/auv_ekf/config/ekf_params.yaml, src/auv_ekf/CMakeLists.txt]
autonomous: false

must_haves:
  truths:
    - "EKF node launches with simulation"
    - "EKF publishes pose estimate that tracks ground truth"
    - "Position estimate error < 1m after 30 seconds"
  artifacts:
    - path: "src/auv_ekf/launch/ekf.launch.py"
      provides: "Launch file for EKF node"
      contains: "ekf_node"
    - path: "src/auv_ekf/config/ekf_params.yaml"
      provides: "Tunable EKF parameters"
      contains: "process_noise"
  key_links:
    - from: "ekf.launch.py"
      to: "ekf_node"
      via: "Node launch"
      pattern: "Node"
---

<objective>
Create launch file and verify EKF against ground truth.

Purpose: Make EKF launchable and validate it tracks the true state - final verification for Phase 2.
Output: Working EKF that can be launched with simulation and verified by human.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-navigation/02-01-SUMMARY.md
@.planning/phases/02-navigation/02-02-SUMMARY.md
@.planning/phases/02-navigation/02-03-SUMMARY.md

**Ground truth topic:**
- Odometry @ 50Hz → `/auv/odometry` (ground truth from Stonefish)

**EKF output topic:**
- Pose @ 50Hz → `/auv/ekf/pose` (filtered estimate)

**Verification approach:**
1. Launch simulation + EKF
2. Let AUV float (no control yet)
3. Compare EKF pose to ground truth odometry
4. EKF should track true state within reasonable error
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create launch file and parameters</name>
  <files>src/auv_ekf/launch/ekf.launch.py, src/auv_ekf/config/ekf_params.yaml, src/auv_ekf/CMakeLists.txt</files>
  <action>
Create directories: launch/, config/

Create ekf_params.yaml:
```yaml
ekf_node:
  ros__parameters:
    # Prediction rate
    predict_rate: 50.0  # Hz

    # Initial state uncertainty
    initial_position_uncertainty: 1.0  # meters
    initial_velocity_uncertainty: 0.5  # m/s
    initial_orientation_uncertainty: 0.1  # radians
    initial_angular_velocity_uncertainty: 0.1  # rad/s

    # Process noise (per second)
    process_noise_position: 0.01  # m²/s
    process_noise_velocity: 0.1  # (m/s)²/s
    process_noise_orientation: 0.001  # rad²/s
    process_noise_angular_velocity: 0.01  # (rad/s)²/s

    # Measurement noise
    imu_orientation_noise: 0.01  # radians
    imu_angular_velocity_noise: 0.01  # rad/s
    pressure_depth_noise: 0.1  # meters
    dvl_velocity_noise: 0.01  # m/s

    # Dead reckoning
    sensor_timeout: 1.0  # seconds
```

Create ekf.launch.py:
```python
from launch import LaunchDescription
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    pkg_dir = get_package_share_directory('auv_ekf')
    params_file = os.path.join(pkg_dir, 'config', 'ekf_params.yaml')

    return LaunchDescription([
        Node(
            package='auv_ekf',
            executable='ekf_node',
            name='ekf_node',
            output='screen',
            parameters=[params_file],
            remappings=[
                ('/auv/imu', '/auv/imu'),
                ('/auv/dvl', '/auv/dvl'),
                ('/auv/pressure', '/auv/pressure'),
            ]
        )
    ])
```

Update CMakeLists.txt to install launch/ and config/ directories:
```cmake
install(DIRECTORY launch config
  DESTINATION share/${PROJECT_NAME}
)
```

Update ekf_node.cpp to read parameters:
- Use declare_parameter() and get_parameter() for all tunable values
- Apply parameters to noise matrices and timing
  </action>
  <verify>ros2 launch auv_ekf ekf.launch.py --show-args shows parameters</verify>
  <done>Launch file created with configurable parameters</done>
</task>

<task type="auto">
  <name>Task 2: Update EKF to use parameters</name>
  <files>src/auv_ekf/src/ekf_node.cpp</files>
  <action>
Update EKF constructor to declare and use ROS2 parameters:

1. Declare all parameters with defaults:
```cpp
this->declare_parameter("predict_rate", 50.0);
this->declare_parameter("initial_position_uncertainty", 1.0);
// ... etc for all parameters in yaml
```

2. Get parameters and apply:
```cpp
double predict_rate = this->get_parameter("predict_rate").as_double();
double init_pos_unc = this->get_parameter("initial_position_uncertainty").as_double();
// ... etc
```

3. Initialize covariance from parameters:
```cpp
covariance_.setIdentity();
covariance_.block<3,3>(X, X) *= init_pos_unc * init_pos_unc;
covariance_.block<3,3>(VX, VX) *= init_vel_unc * init_vel_unc;
covariance_.block<3,3>(ROLL, ROLL) *= init_orient_unc * init_orient_unc;
covariance_.block<3,3>(WX, WX) *= init_angvel_unc * init_angvel_unc;
```

4. Initialize process noise Q from parameters (similar pattern)

5. Initialize measurement noise R matrices from parameters

6. Create timer with parameterized rate:
```cpp
auto period = std::chrono::duration<double>(1.0 / predict_rate);
predict_timer_ = this->create_wall_timer(
    std::chrono::duration_cast<std::chrono::nanoseconds>(period),
    std::bind(&EkfNode::predict, this));
```

This makes EKF tunable without recompilation.
  </action>
  <verify>colcon build --packages-select auv_ekf compiles</verify>
  <done>EKF reads all parameters from yaml/launch</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete EKF system with sensor fusion (IMU, DVL, pressure) and dead reckoning</what-built>
  <how-to-verify>
    1. Start simulation: (in container)
       colcon build
       source install/setup.bash
       ros2 launch auv_sim simulation.launch.py

    2. In another terminal (in container), start EKF:
       source install/setup.bash
       ros2 launch auv_ekf ekf.launch.py

    3. Check topics:
       ros2 topic list | grep ekf
       Should see: /auv/ekf/pose

    4. Compare EKF to ground truth:
       ros2 topic echo /auv/ekf/pose --once
       ros2 topic echo /auv/odometry --once

    5. Verify EKF is updating:
       ros2 topic hz /auv/ekf/pose
       Should be ~50Hz

    6. Let run for 30 seconds, verify:
       - Position estimates are reasonable (not drifting wildly)
       - Depth tracks actual depth (Z coordinate)
       - No error spam in EKF terminal

    7. (Optional) Plot comparison using rqt_plot or save to bag
  </how-to-verify>
  <resume-signal>Type "approved" if EKF tracks ground truth reasonably, or describe issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] colcon build --packages-select auv_ekf succeeds
- [ ] Launch file works: ros2 launch auv_ekf ekf.launch.py
- [ ] EKF publishes to /auv/ekf/pose at ~50Hz
- [ ] EKF tracks ground truth (human verified)
</verification>

<success_criteria>
- All tasks completed
- Launch file and parameters work
- EKF publishes filtered pose
- Human verified EKF tracks ground truth
- Dead reckoning mode works when sensors timeout
</success_criteria>

<output>
After completion, create `.planning/phases/02-navigation/02-04-SUMMARY.md`
</output>
