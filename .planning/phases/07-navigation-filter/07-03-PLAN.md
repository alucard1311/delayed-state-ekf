---
phase: 07-navigation-filter
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - src/usbl_navigation/include/usbl_navigation/navigation_node.hpp
  - src/usbl_navigation/src/nodes/navigation_node.cpp
  - src/usbl_navigation/src/nodes/navigation_main.cpp
  - src/usbl_navigation/CMakeLists.txt
  - src/usbl_navigation/launch/simulation.launch.py
autonomous: true

must_haves:
  truths:
    - "Navigation node subscribes to /imu/data, /dvl/twist, /usbl/position"
    - "Odometry published at 50Hz on /navigation/odometry"
    - "TF broadcast world->odom->base_link"
    - "USBL outlier rejection visible in logs"
    - "Position error decreases after USBL fix"
  artifacts:
    - path: "src/usbl_navigation/include/usbl_navigation/navigation_node.hpp"
      provides: "NavigationNode class declaration"
      contains: "DelayedStateEKF"
    - path: "src/usbl_navigation/src/nodes/navigation_node.cpp"
      provides: "ROS2 node implementation"
      min_lines: 150
    - path: "src/usbl_navigation/launch/simulation.launch.py"
      provides: "Complete simulation launch"
      contains: "navigation_node"
  key_links:
    - from: "navigation_node.cpp"
      to: "delayed_state_ekf"
      via: "ekf_.predict() in IMU callback"
      pattern: "ekf_\\.predict"
    - from: "navigation_node.cpp"
      to: "/navigation/odometry"
      via: "odom_pub_->publish"
      pattern: "odom_pub_.*publish"
---

<objective>
Create the ROS2 navigation node that wraps DelayedStateEKF and connects it to sensor topics.

Purpose: Provide real-time navigation output by fusing IMU, DVL, and delayed USBL measurements through the EKF.

Output: Complete navigation system ready for demo and visualization in Phase 8.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Prior plans established:
- 07-01: DelayedStateEKF class with state buffer and prediction
- 07-02: DVL and USBL measurement updates with Mahalanobis gating

Phase 6 topics (sensors publishing):
- /truth/odometry (nav_msgs/Odometry, 100Hz)
- /imu/data (sensor_msgs/Imu, 100Hz)
- /dvl/twist (geometry_msgs/TwistStamped, 5Hz)
- /dvl/bottom_lock (std_msgs/Bool, 5Hz)
- /usbl/position (geometry_msgs/PointStamped, 0.2Hz with DELAYED timestamps)
- /usbl/valid (std_msgs/Bool, 0.2Hz)

EKF configuration:
@src/usbl_navigation/config/ekf_params.yaml

Existing launch file:
@src/usbl_navigation/launch/simulation.launch.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create navigation_node with sensor subscriptions and EKF</name>
  <files>
    src/usbl_navigation/include/usbl_navigation/navigation_node.hpp,
    src/usbl_navigation/src/nodes/navigation_node.cpp,
    src/usbl_navigation/src/nodes/navigation_main.cpp
  </files>
  <action>
**Create navigation_node.hpp:**

```cpp
#ifndef USBL_NAVIGATION__NAVIGATION_NODE_HPP_
#define USBL_NAVIGATION__NAVIGATION_NODE_HPP_

#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/imu.hpp>
#include <geometry_msgs/msg/twist_stamped.hpp>
#include <geometry_msgs/msg/point_stamped.hpp>
#include <nav_msgs/msg/odometry.hpp>
#include <std_msgs/msg/bool.hpp>
#include <tf2_ros/transform_broadcaster.h>

#include "usbl_navigation/delayed_state_ekf.hpp"

namespace usbl_navigation {

class NavigationNode : public rclcpp::Node {
public:
  explicit NavigationNode(const rclcpp::NodeOptions& options = rclcpp::NodeOptions());

private:
  // Sensor callbacks
  void imuCallback(const sensor_msgs::msg::Imu::SharedPtr msg);
  void dvlCallback(const geometry_msgs::msg::TwistStamped::SharedPtr msg);
  void dvlValidCallback(const std_msgs::msg::Bool::SharedPtr msg);
  void usblCallback(const geometry_msgs::msg::PointStamped::SharedPtr msg);
  void usblValidCallback(const std_msgs::msg::Bool::SharedPtr msg);

  // Timer callback for publishing
  void publishTimerCallback();

  // Helper methods
  void publishOdometry();
  void broadcastTf();

  // EKF
  std::unique_ptr<DelayedStateEKF> ekf_;

  // Subscribers
  rclcpp::Subscription<sensor_msgs::msg::Imu>::SharedPtr imu_sub_;
  rclcpp::Subscription<geometry_msgs::msg::TwistStamped>::SharedPtr dvl_sub_;
  rclcpp::Subscription<std_msgs::msg::Bool>::SharedPtr dvl_valid_sub_;
  rclcpp::Subscription<geometry_msgs::msg::PointStamped>::SharedPtr usbl_sub_;
  rclcpp::Subscription<std_msgs::msg::Bool>::SharedPtr usbl_valid_sub_;

  // Publishers
  rclcpp::Publisher<nav_msgs::msg::Odometry>::SharedPtr odom_pub_;

  // TF broadcaster
  std::unique_ptr<tf2_ros::TransformBroadcaster> tf_broadcaster_;

  // Timer for publishing at fixed rate
  rclcpp::TimerBase::SharedPtr publish_timer_;

  // State tracking
  rclcpp::Time last_imu_time_;
  bool dvl_valid_;
  bool usbl_valid_;
  bool initialized_;

  // Parameters
  double publish_rate_;
  Eigen::Matrix3d R_dvl_;   // DVL measurement noise
  Eigen::Matrix3d R_usbl_;  // USBL measurement noise
};

}  // namespace usbl_navigation

#endif
```

**Create navigation_node.cpp:**

Constructor:
- Declare and load parameters from ekf_params.yaml
- Create DelayedStateEKF instance and configure process/measurement noise
- Create subscribers for /imu/data, /dvl/twist, /dvl/bottom_lock, /usbl/position, /usbl/valid
- Create publisher for /navigation/odometry
- Create TF broadcaster
- Create timer for 50Hz publishing

IMU callback:
```cpp
void NavigationNode::imuCallback(const sensor_msgs::msg::Imu::SharedPtr msg) {
  // Create IMU measurement
  ImuMeasurement imu;
  imu.timestamp = msg->header.stamp;
  imu.gyro = Eigen::Vector3d(msg->angular_velocity.x,
                              msg->angular_velocity.y,
                              msg->angular_velocity.z);
  imu.accel = Eigen::Vector3d(msg->linear_acceleration.x,
                               msg->linear_acceleration.y,
                               msg->linear_acceleration.z);

  // Calculate dt
  if (!initialized_) {
    last_imu_time_ = imu.timestamp;
    initialized_ = true;
    return;
  }

  double dt = (imu.timestamp - last_imu_time_).seconds();
  if (dt <= 0 || dt > 0.1) {
    last_imu_time_ = imu.timestamp;
    return;  // Skip invalid dt
  }

  // Run EKF prediction
  ekf_->predict(imu, dt);
  last_imu_time_ = imu.timestamp;
}
```

DVL callback:
```cpp
void NavigationNode::dvlCallback(const geometry_msgs::msg::TwistStamped::SharedPtr msg) {
  if (!initialized_ || !dvl_valid_) return;

  Eigen::Vector3d v_body(msg->twist.linear.x,
                          msg->twist.linear.y,
                          msg->twist.linear.z);

  ekf_->updateDvl(v_body, R_dvl_);
}
```

USBL callback:
```cpp
void NavigationNode::usblCallback(const geometry_msgs::msg::PointStamped::SharedPtr msg) {
  if (!initialized_ || !usbl_valid_) return;

  Eigen::Vector3d position(msg->point.x, msg->point.y, msg->point.z);

  // Use message timestamp (which is the delayed measurement time)
  bool accepted = ekf_->updateUsblDelayed(position, msg->header.stamp, R_usbl_);

  if (accepted) {
    RCLCPP_INFO(this->get_logger(), "USBL fix applied: delay=%.2fs, pos=[%.1f, %.1f, %.1f]",
                (this->now() - msg->header.stamp).seconds(),
                position.x(), position.y(), position.z());
  }
}
```

Publish timer callback:
- Get state from EKF
- Build Odometry message with pose and twist
- Publish odometry
- Broadcast TF (world -> base_link)

**Create navigation_main.cpp:**
Standard ROS2 node main function.
  </action>
  <verify>
Files exist: `ls -la src/usbl_navigation/src/nodes/navigation_*.cpp src/usbl_navigation/include/usbl_navigation/navigation_node.hpp`
  </verify>
  <done>NavigationNode class created with sensor callbacks and EKF integration</done>
</task>

<task type="auto">
  <name>Task 2: Update CMakeLists.txt and build navigation node</name>
  <files>src/usbl_navigation/CMakeLists.txt</files>
  <action>
Add to CMakeLists.txt:

1. Add the ekf source directory to the build:
```cmake
# EKF library
add_library(delayed_state_ekf SHARED
  src/ekf/delayed_state_ekf.cpp
)
target_include_directories(delayed_state_ekf PUBLIC
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
  $<INSTALL_INTERFACE:include>
)
target_link_libraries(delayed_state_ekf
  Eigen3::Eigen
)
ament_target_dependencies(delayed_state_ekf
  rclcpp
)
```

2. Add navigation_node executable:
```cmake
# Navigation node executable
add_executable(navigation_node
  src/nodes/navigation_node.cpp
  src/nodes/navigation_main.cpp
)
target_include_directories(navigation_node PUBLIC
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
  $<INSTALL_INTERFACE:include>
)
target_link_libraries(navigation_node
  delayed_state_ekf
  Eigen3::Eigen
)
ament_target_dependencies(navigation_node
  rclcpp
  sensor_msgs
  geometry_msgs
  nav_msgs
  std_msgs
  tf2_ros
)
```

3. Add to install targets:
```cmake
install(TARGETS
  delayed_state_ekf
  navigation_node
  truth_generator_node
  imu_simulator_node
  dvl_simulator_node
  usbl_simulator_node
  DESTINATION lib/${PROJECT_NAME}
)
```

4. Make sure tf2_ros is in package.xml dependencies (add if missing).

Build and verify:
```bash
cd /home/vinay/stonefish_ws
colcon build --packages-select usbl_navigation
```
  </action>
  <verify>
Build succeeds: `cd /home/vinay/stonefish_ws && colcon build --packages-select usbl_navigation 2>&1 | tail -20`
Executable exists: `ls -la /home/vinay/stonefish_ws/install/usbl_navigation/lib/usbl_navigation/navigation_node`
  </verify>
  <done>navigation_node executable builds successfully</done>
</task>

<task type="auto">
  <name>Task 3: Update launch file and verify integration</name>
  <files>src/usbl_navigation/launch/simulation.launch.py</files>
  <action>
Update simulation.launch.py to include navigation_node:

Add navigation_node to the launch file after the sensor simulators:
```python
navigation_node = Node(
    package='usbl_navigation',
    executable='navigation_node',
    name='navigation_node',
    output='screen',
    parameters=[
        ekf_params_file,
        sensor_noise_file,
    ],
)
```

Add to LaunchDescription return statement.

**Verify integration:**

1. Build everything:
```bash
cd /home/vinay/stonefish_ws
colcon build --packages-select usbl_navigation
source install/setup.bash
```

2. Launch simulation (in Docker or native):
```bash
ros2 launch usbl_navigation simulation.launch.py
```

3. Check topics are publishing:
```bash
ros2 topic list | grep -E "navigation|truth|imu|dvl|usbl"
ros2 topic hz /navigation/odometry  # Should be ~50Hz
```

4. Echo a few odometry messages to verify state is updating:
```bash
ros2 topic echo /navigation/odometry --once
```

5. Watch for USBL fix logs (every ~5 seconds):
```bash
# In terminal running launch, look for "USBL fix applied" or "USBL outlier rejected"
```

If launch fails or topics don't appear, debug by checking node logs.
  </action>
  <verify>
Launch file updated: `grep -n navigation_node src/usbl_navigation/launch/simulation.launch.py`
Build succeeds: `cd /home/vinay/stonefish_ws && colcon build --packages-select usbl_navigation 2>&1 | tail -5`
  </verify>
  <done>
- Launch file includes navigation_node
- All nodes launch together
- /navigation/odometry publishes at 50Hz
- USBL fixes visible in logs (accepted or rejected)
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `colcon build --packages-select usbl_navigation` succeeds
- [ ] navigation_node executable exists in install directory
- [ ] Launch file includes navigation_node
- [ ] /navigation/odometry topic publishes when launched
- [ ] IMU triggers prediction (100Hz internal rate)
- [ ] DVL updates velocity when bottom_lock=true
- [ ] USBL delayed updates visible in logs
</verification>

<success_criteria>

- NavigationNode wraps DelayedStateEKF with ROS2 interface
- Subscribes to /imu/data, /dvl/twist, /usbl/position
- Publishes /navigation/odometry at 50Hz
- TF broadcast for world->base_link
- Complete navigation system ready for Phase 8 visualization
  </success_criteria>

<output>
After completion, create `.planning/phases/07-navigation-filter/07-03-SUMMARY.md`
</output>
