---
phase: 07-navigation-filter
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/usbl_navigation/include/usbl_navigation/delayed_state_ekf.hpp
  - src/usbl_navigation/src/ekf/delayed_state_ekf.cpp
autonomous: true

must_haves:
  truths:
    - "EKF state vector contains 15 elements (pos3, vel3, quat4, gyro_bias3, accel_bias3)"
    - "State buffer stores timestamped historical states"
    - "IMU integration updates state with bias-corrected measurements"
    - "Quaternion remains normalized after prediction"
  artifacts:
    - path: "src/usbl_navigation/include/usbl_navigation/delayed_state_ekf.hpp"
      provides: "15-state EKF class with state buffer"
      contains: "StateBuffer"
    - path: "src/usbl_navigation/src/ekf/delayed_state_ekf.cpp"
      provides: "Prediction implementation"
      min_lines: 150
  key_links:
    - from: "delayed_state_ekf.cpp"
      to: "StateBuffer"
      via: "storeState() call in predict()"
      pattern: "state_buffer_.*store"
---

<objective>
Create the delayed-state EKF core with 15-state vector and state buffer for historical state lookup.

Purpose: Enable delayed USBL measurement updates by storing historical states that can be corrected and repropagated to current time.

Output: DelayedStateEKF class with prediction step ready for measurement updates in Plan 07-02.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Prior phase context (Phase 6 established):
- NED coordinate convention (North-East-Down)
- Eigen for quaternion math (Eigen::Quaterniond)
- Sensor noise parameters in config/ekf_params.yaml
- IMU publishes at 100Hz on /imu/data (sensor_msgs/Imu)

v1.0 EKF reference (patterns to follow):
@src/auv_ekf/include/auv_ekf/ekf_node.hpp
@src/auv_ekf/src/ekf_node.cpp

Config with EKF parameters:
@src/usbl_navigation/config/ekf_params.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create delayed_state_ekf.hpp with 15-state vector and state buffer</name>
  <files>src/usbl_navigation/include/usbl_navigation/delayed_state_ekf.hpp</files>
  <action>
Create header file for DelayedStateEKF class with:

**State Vector (15 elements):**
```cpp
enum StateIdx {
  PX = 0, PY = 1, PZ = 2,           // Position (NED)
  VX = 3, VY = 4, VZ = 5,           // Velocity (body frame)
  QW = 6, QX = 7, QY = 8, QZ = 9,   // Quaternion (w, x, y, z)
  BGX = 10, BGY = 11, BGZ = 12,     // Gyro bias
  BAX = 13, BAY = 14, BAZ = 15      // Accel bias (actually index 15, so STATE_SIZE = 16)
};
// Note: Use 16-state internally but conceptually 15 independent (quat is unit)
```

Wait - quaternion has 4 components but 3 DOF. Keep STATE_SIZE = 16 for Eigen but the quaternion constraint is handled during prediction.

**StateBuffer struct:**
```cpp
struct BufferedState {
  rclcpp::Time timestamp;
  Eigen::Matrix<double, 16, 1> state;
  Eigen::Matrix<double, 16, 16> covariance;
};
```

**Class members:**
- `Eigen::Matrix<double, 16, 1> state_` - current state
- `Eigen::Matrix<double, 16, 16> P_` - covariance
- `Eigen::Matrix<double, 16, 16> Q_` - process noise
- `std::deque<BufferedState> state_buffer_` - circular buffer
- `std::deque<ImuMeasurement> imu_buffer_` - IMU history for repropagation
- `size_t buffer_size_` - max buffer entries (default 500)
- `double mahalanobis_threshold_` - outlier rejection threshold

**ImuMeasurement struct:**
```cpp
struct ImuMeasurement {
  rclcpp::Time timestamp;
  Eigen::Vector3d gyro;   // rad/s (raw, not bias-corrected)
  Eigen::Vector3d accel;  // m/s^2 (raw, includes gravity)
};
```

**Public methods:**
- `void predict(const ImuMeasurement& imu, double dt)` - IMU integration
- `void updateDvl(const Eigen::Vector3d& velocity_body, const Eigen::Matrix3d& R)` - DVL update
- `bool updateUsblDelayed(const Eigen::Vector3d& position, const rclcpp::Time& meas_time, const Eigen::Matrix3d& R)` - delayed USBL
- `Eigen::Matrix<double, 16, 1> getState() const`
- `Eigen::Matrix<double, 16, 16> getCovariance() const`
- `void setProcessNoise(...params...)` - configure Q
- `void setMahalanobisThreshold(double threshold)`

**Private methods:**
- `void normalizeQuaternion()` - ensure ||q|| = 1
- `void storeState(const rclcpp::Time& time)` - add to buffer
- `bool findBufferedState(const rclcpp::Time& time, BufferedState& out)` - lookup
- `void repropagateFrom(const rclcpp::Time& from_time)` - replay IMU from corrected state
- `Eigen::Matrix3d quaternionToRotationMatrix() const`
- `Eigen::Vector3d rotateBodyToNed(const Eigen::Vector3d& v_body) const`

Use `usbl_navigation` namespace.
  </action>
  <verify>File compiles: `cd /home/vinay/stonefish_ws && colcon build --packages-select usbl_navigation --cmake-args -DCMAKE_BUILD_TYPE=Release 2>&1 | head -50`</verify>
  <done>Header exists with complete class declaration, compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Implement EKF prediction step with IMU integration</name>
  <files>src/usbl_navigation/src/ekf/delayed_state_ekf.cpp</files>
  <action>
Create implementation file. First create the directory: `mkdir -p src/usbl_navigation/src/ekf`

**Constructor:**
- Initialize state to zeros, quaternion to identity (w=1, x=y=z=0)
- Initialize covariance P with reasonable initial uncertainties
- Initialize process noise Q from parameters
- Set buffer_size_ = 500, mahalanobis_threshold_ = 9.21 (default)

**predict() method - strapdown IMU integration:**
```cpp
void DelayedStateEKF::predict(const ImuMeasurement& imu, double dt) {
  // Store IMU measurement for potential repropagation
  imu_buffer_.push_back(imu);
  trimImuBuffer();  // Keep only last ~5 seconds

  // Bias-corrected measurements
  Eigen::Vector3d gyro = imu.gyro - state_.segment<3>(BGX);
  Eigen::Vector3d accel = imu.accel - state_.segment<3>(BAX);

  // Extract current quaternion
  Eigen::Quaterniond q(state_(QW), state_(QX), state_(QY), state_(QZ));

  // Orientation update (first-order quaternion integration)
  Eigen::Quaterniond dq;
  double angle = gyro.norm() * dt;
  if (angle > 1e-10) {
    Eigen::Vector3d axis = gyro.normalized();
    dq = Eigen::Quaterniond(Eigen::AngleAxisd(angle, axis));
  } else {
    dq = Eigen::Quaterniond::Identity();
  }
  q = q * dq;  // Body frame rotation update
  q.normalize();

  // Rotate acceleration to NED frame and remove gravity
  Eigen::Matrix3d R = q.toRotationMatrix();
  Eigen::Vector3d accel_ned = R * accel;
  Eigen::Vector3d gravity(0, 0, 9.81);  // NED: gravity points down (+Z)
  Eigen::Vector3d accel_corrected = accel_ned - gravity;

  // Velocity update (NED frame)
  state_.segment<3>(VX) += accel_corrected * dt;

  // Position update (NED frame)
  state_.segment<3>(PX) += state_.segment<3>(VX) * dt;

  // Update quaternion in state
  state_(QW) = q.w();
  state_(QX) = q.x();
  state_(QY) = q.y();
  state_(QZ) = q.z();

  // Bias states remain unchanged (random walk modeled in Q)

  // Covariance prediction: P = F * P * F^T + Q
  // F is the state transition Jacobian
  Eigen::Matrix<double, 16, 16> F = computeStateTransitionJacobian(gyro, accel, q, dt);
  P_ = F * P_ * F.transpose() + Q_ * dt;

  // Store state in buffer for delayed updates
  storeState(imu.timestamp);
}
```

**computeStateTransitionJacobian() method:**
Compute the 16x16 Jacobian F. Key non-identity blocks:
- dPos/dVel = I_3 * dt (velocity integrates to position)
- dVel/dQuat = partial of R*accel w.r.t. quaternion (complex, can approximate)
- dVel/dAccelBias = -R * dt
- dQuat/dQuat = quaternion propagation Jacobian
- dQuat/dGyroBias = -dt * (small angle approx)

Simplify where appropriate - the main goal is stable filter behavior.

**Helper methods:**
- `normalizeQuaternion()` - renormalize if ||q|| deviates from 1
- `storeState()` - add current state/cov/time to buffer, trim if > buffer_size_
- `trimImuBuffer()` - remove IMU measurements older than oldest buffered state
- `quaternionToRotationMatrix()` - extract rotation from state quaternion

**Important:** Velocity in state is stored in NED frame (not body frame) - this simplifies position integration. DVL provides body-frame velocity, so we'll transform in the update step.
  </action>
  <verify>
Build succeeds: `cd /home/vinay/stonefish_ws && colcon build --packages-select usbl_navigation 2>&1 | tail -20`
Check file exists with implementation: `wc -l src/usbl_navigation/src/ekf/delayed_state_ekf.cpp`
  </verify>
  <done>
- delayed_state_ekf.cpp exists with >150 lines
- predict() implements strapdown IMU integration
- State buffer stores history for delayed updates
- Build completes without errors
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `colcon build --packages-select usbl_navigation` succeeds
- [ ] delayed_state_ekf.hpp declares 16-state vector with quaternion
- [ ] delayed_state_ekf.cpp implements predict() with IMU integration
- [ ] State buffer struct and storage methods implemented
- [ ] No compiler warnings in the EKF files
</verification>

<success_criteria>

- DelayedStateEKF class created with 15-state (16-element) vector
- Prediction step integrates IMU with bias removal
- State buffer stores historical states with timestamps
- Quaternion normalization maintains unit norm
- Ready for DVL and USBL updates in Plan 07-02
  </success_criteria>

<output>
After completion, create `.planning/phases/07-navigation-filter/07-01-SUMMARY.md`
</output>
