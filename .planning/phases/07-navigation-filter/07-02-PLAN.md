---
phase: 07-navigation-filter
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/usbl_navigation/src/ekf/delayed_state_ekf.cpp
  - src/usbl_navigation/include/usbl_navigation/delayed_state_ekf.hpp
autonomous: true

must_haves:
  truths:
    - "DVL update reduces velocity uncertainty"
    - "USBL update finds historical state by timestamp"
    - "Outliers rejected via Mahalanobis gating"
    - "State repropagated to current time after USBL correction"
  artifacts:
    - path: "src/usbl_navigation/src/ekf/delayed_state_ekf.cpp"
      provides: "DVL and USBL measurement updates"
      contains: "updateUsblDelayed"
  key_links:
    - from: "updateUsblDelayed"
      to: "findBufferedState"
      via: "lookup historical state by measurement timestamp"
      pattern: "findBufferedState.*meas_time"
    - from: "updateUsblDelayed"
      to: "repropagateFrom"
      via: "replay IMU after correction"
      pattern: "repropagateFrom"
---

<objective>
Implement DVL velocity update and USBL delayed position update with Mahalanobis outlier rejection and state repropagation.

Purpose: Enable the EKF to incorporate DVL velocity measurements and correctly handle delayed USBL position measurements by correcting historical state and repropagating to current time.

Output: Complete DelayedStateEKF class ready for integration with ROS2 navigation node in Plan 07-03.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Prior plan context (07-01 established):
- DelayedStateEKF class with 16-state vector
- predict() with IMU integration
- State buffer storing historical states
- IMU buffer for repropagation

Phase 6 sensor behavior:
- DVL publishes body-frame velocity on /dvl/twist at 5Hz
- USBL publishes NED position on /usbl/position at 0.2Hz with DELAYED timestamps
- USBL has 10% dropouts and 5% outliers (5m offset)

EKF parameters:
@src/usbl_navigation/config/ekf_params.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DVL velocity measurement update</name>
  <files>src/usbl_navigation/src/ekf/delayed_state_ekf.cpp</files>
  <action>
Add updateDvl() method to DelayedStateEKF:

**DVL Update Logic:**
DVL measures body-frame velocity. Our state stores NED-frame velocity. We need to handle this properly.

Option A: Transform measurement to NED and update NED velocity directly.
Option B: Transform state velocity to body frame for innovation calculation.

Use Option A (simpler):
```cpp
void DelayedStateEKF::updateDvl(const Eigen::Vector3d& v_body, const Eigen::Matrix3d& R_meas) {
  // Get current rotation from body to NED
  Eigen::Quaterniond q(state_(QW), state_(QX), state_(QY), state_(QZ));
  Eigen::Matrix3d R = q.toRotationMatrix();

  // Transform body velocity measurement to NED frame
  Eigen::Vector3d v_ned_meas = R * v_body;

  // Measurement vector (3 elements: velocity in NED)
  Eigen::Vector3d z = v_ned_meas;

  // Predicted measurement (velocity states in NED)
  Eigen::Vector3d z_pred = state_.segment<3>(VX);

  // Innovation
  Eigen::Vector3d y = z - z_pred;

  // Measurement matrix H (3x16): maps state to velocity measurement
  // H selects [VX, VY, VZ] from state
  Eigen::Matrix<double, 3, 16> H = Eigen::Matrix<double, 3, 16>::Zero();
  H(0, VX) = 1.0;
  H(1, VY) = 1.0;
  H(2, VZ) = 1.0;

  // Transform measurement noise from body to NED frame
  // R_ned = R * R_body * R^T (for covariance transformation)
  Eigen::Matrix3d R_ned = R * R_meas * R.transpose();

  // Innovation covariance: S = H * P * H^T + R
  Eigen::Matrix3d S = H * P_ * H.transpose() + R_ned;

  // Kalman gain: K = P * H^T * S^-1
  Eigen::Matrix<double, 16, 3> K = P_ * H.transpose() * S.inverse();

  // State update
  state_ += K * y;

  // Covariance update (Joseph form for numerical stability)
  Eigen::Matrix<double, 16, 16> I = Eigen::Matrix<double, 16, 16>::Identity();
  Eigen::Matrix<double, 16, 16> IKH = I - K * H;
  P_ = IKH * P_ * IKH.transpose() + K * R_ned * K.transpose();

  // Renormalize quaternion
  normalizeQuaternion();
}
```

**Note:** DVL updates are not delayed, so no state buffer lookup needed. Apply directly to current state.
  </action>
  <verify>Build succeeds: `cd /home/vinay/stonefish_ws && colcon build --packages-select usbl_navigation 2>&1 | tail -10`</verify>
  <done>updateDvl() implemented with body-to-NED transformation and standard EKF update</done>
</task>

<task type="auto">
  <name>Task 2: Implement USBL delayed update with Mahalanobis gating and repropagation</name>
  <files>src/usbl_navigation/src/ekf/delayed_state_ekf.cpp</files>
  <action>
Add updateUsblDelayed() method - the key delayed-state EKF logic:

```cpp
bool DelayedStateEKF::updateUsblDelayed(
    const Eigen::Vector3d& position_ned,
    const rclcpp::Time& meas_time,
    const Eigen::Matrix3d& R_meas)
{
  // Step 1: Find buffered state at measurement time
  BufferedState buffered;
  if (!findBufferedState(meas_time, buffered)) {
    // Measurement too old (not in buffer) - reject
    RCLCPP_WARN(rclcpp::get_logger("DelayedStateEKF"),
                "USBL measurement too old (%.3fs), rejecting",
                (current_time_ - meas_time).seconds());
    return false;
  }

  // Step 2: Compute innovation using buffered state
  Eigen::Vector3d z = position_ned;
  Eigen::Vector3d z_pred = buffered.state.segment<3>(PX);
  Eigen::Vector3d y = z - z_pred;

  // Step 3: Measurement matrix (position observation)
  Eigen::Matrix<double, 3, 16> H = Eigen::Matrix<double, 3, 16>::Zero();
  H(0, PX) = 1.0;
  H(1, PY) = 1.0;
  H(2, PZ) = 1.0;

  // Step 4: Innovation covariance
  Eigen::Matrix3d S = H * buffered.covariance * H.transpose() + R_meas;

  // Step 5: Mahalanobis distance for outlier rejection
  double mahal_dist_sq = y.transpose() * S.inverse() * y;
  if (mahal_dist_sq > mahalanobis_threshold_) {
    // Outlier detected - reject measurement
    RCLCPP_WARN(rclcpp::get_logger("DelayedStateEKF"),
                "USBL outlier rejected: Mahalanobis^2=%.1f > threshold=%.1f",
                mahal_dist_sq, mahalanobis_threshold_);
    return false;
  }

  // Step 6: Kalman gain using buffered covariance
  Eigen::Matrix<double, 16, 3> K = buffered.covariance * H.transpose() * S.inverse();

  // Step 7: Update buffered state (at measurement time)
  Eigen::Matrix<double, 16, 1> state_corrected = buffered.state + K * y;

  // Normalize quaternion in corrected state
  Eigen::Quaterniond q_corr(state_corrected(QW), state_corrected(QX),
                            state_corrected(QY), state_corrected(QZ));
  q_corr.normalize();
  state_corrected(QW) = q_corr.w();
  state_corrected(QX) = q_corr.x();
  state_corrected(QY) = q_corr.y();
  state_corrected(QZ) = q_corr.z();

  // Update covariance at measurement time
  Eigen::Matrix<double, 16, 16> I = Eigen::Matrix<double, 16, 16>::Identity();
  Eigen::Matrix<double, 16, 16> IKH = I - K * H;
  Eigen::Matrix<double, 16, 16> P_corrected =
      IKH * buffered.covariance * IKH.transpose() + K * R_meas * K.transpose();

  // Step 8: Replace buffered state with corrected state
  // Then repropagate to current time using stored IMU measurements
  repropagateFrom(meas_time, state_corrected, P_corrected);

  RCLCPP_DEBUG(rclcpp::get_logger("DelayedStateEKF"),
               "USBL update applied: delay=%.3fs, innovation=[%.2f, %.2f, %.2f]m",
               (current_time_ - meas_time).seconds(), y(0), y(1), y(2));

  return true;
}
```

**Implement findBufferedState():**
```cpp
bool DelayedStateEKF::findBufferedState(const rclcpp::Time& time, BufferedState& out) {
  if (state_buffer_.empty()) return false;

  // Find states bracketing the measurement time
  for (size_t i = 0; i < state_buffer_.size() - 1; ++i) {
    if (state_buffer_[i].timestamp <= time && state_buffer_[i+1].timestamp > time) {
      // Linear interpolation (or just use earlier state for simplicity)
      out = state_buffer_[i];
      return true;
    }
  }

  // Check if time is before oldest buffered state
  if (time < state_buffer_.front().timestamp) {
    return false;  // Too old
  }

  // Check if time is after newest (shouldn't happen for delayed measurements)
  if (time >= state_buffer_.back().timestamp) {
    out = state_buffer_.back();
    return true;
  }

  return false;
}
```

**Implement repropagateFrom():**
```cpp
void DelayedStateEKF::repropagateFrom(
    const rclcpp::Time& from_time,
    const Eigen::Matrix<double, 16, 1>& corrected_state,
    const Eigen::Matrix<double, 16, 16>& corrected_cov)
{
  // Set state to corrected values
  state_ = corrected_state;
  P_ = corrected_cov;

  // Clear state buffer entries after correction time (they're now invalid)
  while (!state_buffer_.empty() && state_buffer_.back().timestamp > from_time) {
    state_buffer_.pop_back();
  }

  // Replay IMU measurements from correction time to now
  rclcpp::Time prev_time = from_time;
  for (const auto& imu : imu_buffer_) {
    if (imu.timestamp <= from_time) continue;

    double dt = (imu.timestamp - prev_time).seconds();
    if (dt > 0 && dt < 1.0) {
      // Run prediction without storing to buffer (we'll rebuild it)
      predictInternal(imu, dt);
      storeState(imu.timestamp);
    }
    prev_time = imu.timestamp;
  }
}
```

**Add predictInternal() - prediction without IMU buffer update:**
Factor out the core prediction math from predict() so repropagation doesn't duplicate IMU measurements in the buffer.

**Update header:** Add any new private methods declared above.
  </action>
  <verify>
Build succeeds: `cd /home/vinay/stonefish_ws && colcon build --packages-select usbl_navigation 2>&1 | tail -10`
Grep for key methods: `grep -n "updateUsblDelayed\|repropagateFrom\|findBufferedState" src/usbl_navigation/src/ekf/delayed_state_ekf.cpp`
  </verify>
  <done>
- updateUsblDelayed() finds historical state and applies correction
- Mahalanobis gating rejects outliers (threshold from config)
- repropagateFrom() replays IMU to bring state to current time
- Build completes without errors
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `colcon build --packages-select usbl_navigation` succeeds
- [ ] updateDvl() transforms body velocity to NED and updates state
- [ ] updateUsblDelayed() finds historical state by timestamp
- [ ] Mahalanobis gating logs rejected outliers
- [ ] repropagateFrom() replays IMU measurements after correction
- [ ] No compiler warnings
</verification>

<success_criteria>

- DVL update reduces velocity covariance
- USBL delayed update correctly uses historical state
- Outliers rejected via Mahalanobis distance > 9.21
- State repropagated to current time after USBL correction
- DelayedStateEKF class complete, ready for ROS2 integration
  </success_criteria>

<output>
After completion, create `.planning/phases/07-navigation-filter/07-02-SUMMARY.md`
</output>
