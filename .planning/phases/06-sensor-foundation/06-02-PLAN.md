---
phase: 06-sensor-foundation
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/usbl_navigation/include/usbl_navigation/imu_simulator_node.hpp
  - src/usbl_navigation/src/nodes/imu_simulator_node.cpp
  - src/usbl_navigation/src/nodes/imu_simulator_main.cpp
  - src/usbl_navigation/include/usbl_navigation/dvl_simulator_node.hpp
  - src/usbl_navigation/src/nodes/dvl_simulator_node.cpp
  - src/usbl_navigation/src/nodes/dvl_simulator_main.cpp
  - src/usbl_navigation/CMakeLists.txt
  - src/usbl_navigation/launch/simulation.launch.py
autonomous: true

must_haves:
  truths:
    - "IMU publishes data at 100Hz with realistic noise"
    - "IMU bias drifts slowly over time"
    - "DVL publishes body-frame velocity at 5Hz"
    - "DVL drops out during canyon scenario (t=120s-150s)"
    - "DVL bottom_lock status reflects dropout state"
  artifacts:
    - path: "src/usbl_navigation/src/nodes/imu_simulator_node.cpp"
      provides: "IMU simulation with noise and bias"
      min_lines: 80
    - path: "src/usbl_navigation/src/nodes/dvl_simulator_node.cpp"
      provides: "DVL simulation with body-frame conversion and dropouts"
      min_lines: 100
  key_links:
    - from: "imu_simulator_node.cpp"
      to: "/truth/odometry"
      via: "ROS2 subscriber"
    - from: "imu_simulator_node.cpp"
      to: "/imu/data"
      via: "ROS2 publisher at 100Hz"
    - from: "dvl_simulator_node.cpp"
      to: "/truth/odometry"
      via: "ROS2 subscriber"
    - from: "dvl_simulator_node.cpp"
      to: "/dvl/twist"
      via: "ROS2 publisher at 5Hz"
---

<objective>
Create IMU and DVL sensor simulators that add realistic noise and simulate failure modes.

Purpose: Provide noisy sensor data that the delayed-state EKF will fuse, including DVL dropout scenarios.
Output: Working imu_simulator_node and dvl_simulator_node publishing to standard topics.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-sensor-foundation/06-01-SUMMARY.md

Config files created in Plan 06-01:
@src/usbl_navigation/config/sensor_noise.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create imu_simulator_node with noise and bias drift</name>
  <files>
    src/usbl_navigation/include/usbl_navigation/imu_simulator_node.hpp
    src/usbl_navigation/src/nodes/imu_simulator_node.cpp
    src/usbl_navigation/src/nodes/imu_simulator_main.cpp
  </files>
  <action>
    Create imu_simulator_node that:

    **Header (imu_simulator_node.hpp):**
    - Class ImuSimulatorNode : public rclcpp::Node
    - Subscriber: nav_msgs::msg::Odometry (/truth/odometry)
    - Publisher: sensor_msgs::msg::Imu (/imu/data, 100Hz)
    - State: previous_twist (for acceleration computation), gyro_bias, accel_bias
    - Random number generator: std::mt19937, std::normal_distribution

    **Implementation (imu_simulator_node.cpp):**

    1. **Subscribe to truth odometry:**
       - Store latest twist for velocity differencing
       - Store orientation for gravity removal

    2. **Timer callback at 100Hz:**
       - Compute angular velocity from truth orientation rate
       - Compute linear acceleration from velocity derivative + gravity
       - Add white noise (gyro_noise_density, accel_noise_density)
       - Add evolving bias (random walk with bias_instability)

    3. **Bias evolution (random walk):**
       ```cpp
       // Update biases each timestep
       gyro_bias_ += Eigen::Vector3d::Random() * gyro_bias_instability_ * sqrt(dt);
       accel_bias_ += Eigen::Vector3d::Random() * accel_bias_instability_ * sqrt(dt);
       ```

    4. **IMU message construction:**
       - header.stamp = now()
       - header.frame_id = "imu_link"
       - angular_velocity = true_rate + gyro_bias + white_noise
       - linear_acceleration = true_accel + accel_bias + white_noise (body frame, includes gravity)
       - orientation = truth quaternion (optional, some IMUs provide this)
       - Populate covariance matrices

    5. **Gravity handling:**
       - In NED: gravity = [0, 0, +9.81] m/s²
       - Accelerometer measures: a_meas = a_true - R' * g (where R is body-to-world rotation)
       - This is body-frame specific force

    **Parameters from config/sensor_noise.yaml:**
    - gyro_noise_density, gyro_bias_instability
    - accel_noise_density, accel_bias_instability
    - publish_rate

    **Log bias values periodically** for debugging (every 10s):
    ```cpp
    RCLCPP_INFO(get_logger(), "IMU bias: gyro=[%.4f, %.4f, %.4f], accel=[%.4f, %.4f, %.4f]",
                gyro_bias_.x(), gyro_bias_.y(), gyro_bias_.z(),
                accel_bias_.x(), accel_bias_.y(), accel_bias_.z());
    ```
  </action>
  <verify>
    ros2 topic hz /imu/data shows ~100Hz
    ros2 topic echo /imu/data shows non-zero angular_velocity and linear_acceleration
    Bias drift visible in logs over time
  </verify>
  <done>IMU publishes realistic noisy data at 100Hz with drifting bias</done>
</task>

<task type="auto">
  <name>Task 2: Create dvl_simulator_node with body-frame conversion and dropouts</name>
  <files>
    src/usbl_navigation/include/usbl_navigation/dvl_simulator_node.hpp
    src/usbl_navigation/src/nodes/dvl_simulator_node.cpp
    src/usbl_navigation/src/nodes/dvl_simulator_main.cpp
  </files>
  <action>
    Create dvl_simulator_node that:

    **Header (dvl_simulator_node.hpp):**
    - Class DvlSimulatorNode : public rclcpp::Node
    - Subscriber: nav_msgs::msg::Odometry (/truth/odometry)
    - Publishers:
      - geometry_msgs::msg::TwistWithCovarianceStamped (/dvl/twist, 5Hz)
      - std_msgs::msg::Bool (/dvl/bottom_lock)
    - State: mission_start_time, current_time
    - Random number generator

    **Implementation (dvl_simulator_node.cpp):**

    1. **Subscribe to truth odometry:**
       - Extract world-frame velocity (twist.twist.linear)
       - Extract orientation quaternion

    2. **NED to body frame transformation:**
       ```cpp
       // DVL measures velocity in BODY frame
       Eigen::Quaterniond q(odom.pose.pose.orientation.w,
                           odom.pose.pose.orientation.x,
                           odom.pose.pose.orientation.y,
                           odom.pose.pose.orientation.z);
       Eigen::Vector3d v_ned(odom.twist.twist.linear.x,
                            odom.twist.twist.linear.y,
                            odom.twist.twist.linear.z);
       Eigen::Vector3d v_body = q.inverse() * v_ned;
       ```

    3. **Add noise:**
       - White noise: std_dev = velocity_noise_std (0.02 m/s)
       - Scale factor error: v_measured = v_true * (1 + scale_factor_error)

    4. **Dropout logic:**
       ```cpp
       bool bottom_lock = true;
       double t = (now() - mission_start_time_).seconds();

       // Canyon dropout
       if (t >= canyon_dropout_start && t <= canyon_dropout_end) {
           bottom_lock = false;
           RCLCPP_WARN_THROTTLE(get_logger(), *get_clock(), 5000,
                               "DVL bottom lock lost (canyon)");
       }

       // Random dropout
       if (bottom_lock && random_uniform() < dropout_probability) {
           bottom_lock = false;
       }
       ```

    5. **Publish:**
       - If bottom_lock: publish twist with measured velocity and covariance
       - Always publish bottom_lock status
       - Covariance diagonal: [velocity_noise_std², velocity_noise_std², velocity_noise_std², 0, 0, 0]

    **Parameters from config/sensor_noise.yaml:**
    - velocity_noise_std, scale_factor_error
    - dropout_probability
    - canyon_dropout_start, canyon_dropout_end
    - publish_rate

    **Critical:** DVL only publishes when bottom_lock is true. No measurement during dropout.
  </action>
  <verify>
    ros2 topic hz /dvl/twist shows ~5Hz (when not in dropout)
    ros2 topic echo /dvl/bottom_lock shows True normally, False during t=120-150s
    DVL twist values are in body frame (different from truth NED frame)
  </verify>
  <done>DVL publishes body-frame velocity at 5Hz with canyon dropout simulation</done>
</task>

<task type="auto">
  <name>Task 3: Update CMakeLists.txt and launch file</name>
  <files>
    src/usbl_navigation/CMakeLists.txt
    src/usbl_navigation/launch/simulation.launch.py
  </files>
  <action>
    **CMakeLists.txt updates:**
    - Add imu_simulator_node executable
    - Add dvl_simulator_node executable
    - Install both

    **launch/simulation.launch.py updates:**
    - Uncomment and add imu_simulator_node launch
    - Uncomment and add dvl_simulator_node launch
    - Both load parameters from sensor_noise.yaml
    - output='screen' for both
  </action>
  <verify>
    colcon build --packages-select usbl_navigation succeeds
    ros2 launch usbl_navigation simulation.launch.py starts all 3 nodes
    ros2 topic list shows /truth/odometry, /imu/data, /dvl/twist, /dvl/bottom_lock
  </verify>
  <done>All sensor simulators launch together from single launch file</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] colcon build --packages-select usbl_navigation succeeds
- [ ] ros2 launch usbl_navigation simulation.launch.py runs without errors
- [ ] ros2 topic hz /imu/data shows ~100Hz
- [ ] ros2 topic hz /dvl/twist shows ~5Hz (during normal operation)
- [ ] IMU bias drifts over time (visible in logs)
- [ ] DVL bottom_lock becomes False during t=120-150s
- [ ] DVL twist is in body frame (visibly different from truth NED velocity)
</verification>

<success_criteria>
- All tasks completed
- Package builds without errors
- IMU publishes at 100Hz with noise and drifting bias
- DVL publishes at 5Hz in body frame
- Canyon dropout occurs at t=120-150s (bottom_lock=False)
- Random dropouts occasionally occur (5% probability)
</success_criteria>

<output>
After completion, create `.planning/phases/06-sensor-foundation/06-02-SUMMARY.md`
</output>
