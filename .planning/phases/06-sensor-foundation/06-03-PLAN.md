---
phase: 06-sensor-foundation
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/usbl_navigation/include/usbl_navigation/usbl_simulator_node.hpp
  - src/usbl_navigation/src/nodes/usbl_simulator_node.cpp
  - src/usbl_navigation/src/nodes/usbl_simulator_main.cpp
  - src/usbl_navigation/CMakeLists.txt
  - src/usbl_navigation/launch/simulation.launch.py
autonomous: true

must_haves:
  truths:
    - "USBL publishes at 0.2Hz with DELAYED timestamps (not current time)"
    - "USBL noise is range-dependent: max(2% * range, 0.3m)"
    - "USBL has 10% dropout probability"
    - "USBL injects outliers at 5% probability with 5m offset"
  artifacts:
    - path: "src/usbl_navigation/src/nodes/usbl_simulator_node.cpp"
      provides: "USBL simulation with delays, noise, dropouts, and outliers"
      min_lines: 120
  key_links:
    - from: "usbl_simulator_node.cpp"
      to: "/truth/odometry"
      via: "ROS2 subscriber"
    - from: "usbl_simulator_node.cpp"
      to: "/usbl/position"
      via: "ROS2 publisher at 0.2Hz"
    - from: "usbl_simulator_node.cpp"
      to: "/usbl/valid"
      via: "ROS2 publisher (Bool)"
---

<objective>
Create USBL simulator with delayed timestamps, range-dependent noise, dropouts, and outlier injection.

Purpose: Provide realistic USBL measurements that the delayed-state EKF must handle with its state buffer and repropagation.
Output: Working usbl_simulator_node publishing delayed position measurements to /usbl/position.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-sensor-foundation/06-01-SUMMARY.md
@.planning/phases/06-sensor-foundation/06-02-SUMMARY.md

Config files from Plan 06-01:
@src/usbl_navigation/config/sensor_noise.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usbl_simulator_node header</name>
  <files>
    src/usbl_navigation/include/usbl_navigation/usbl_simulator_node.hpp
  </files>
  <action>
    Create header for UsblSimulatorNode:

    **Class structure:**
    - Class UsblSimulatorNode : public rclcpp::Node
    - Subscriber: nav_msgs::msg::Odometry (/truth/odometry)
    - Publishers:
      - geometry_msgs::msg::PointStamped (/usbl/position, 0.2Hz)
      - std_msgs::msg::Bool (/usbl/valid)
    - State:
      - position_buffer_: circular buffer of (timestamp, position) pairs
      - ship_position_: Eigen::Vector3d (fixed surface position)
      - mission_start_time_: rclcpp::Time
    - Random number generators:
      - std::mt19937 rng_
      - std::normal_distribution<double> noise_dist_
      - std::uniform_real_distribution<double> uniform_dist_

    **Configuration parameters:**
    - range_noise_percent: double (0.02 = 2%)
    - min_noise: double (0.3m)
    - processing_delay: double (0.2s)
    - dropout_probability: double (0.10 = 10%)
    - outlier_probability: double (0.05 = 5%)
    - outlier_offset: double (5.0m)
    - ship_position: vector<double> [x, y, z]
    - publish_rate: double (0.2Hz = 5s period)

    **Methods:**
    - odometryCallback(): Store positions in buffer
    - publishTimer(): Generate and publish USBL measurements
    - computeRange(): Calculate range from ship to AUV
    - addNoise(): Add range-dependent Gaussian noise
    - injectOutlier(): Randomly offset measurement
  </action>
  <verify>Header compiles without errors</verify>
  <done>USBL simulator header with buffer and noise parameters defined</done>
</task>

<task type="auto">
  <name>Task 2: Implement usbl_simulator_node with delayed timestamps</name>
  <files>
    src/usbl_navigation/src/nodes/usbl_simulator_node.cpp
    src/usbl_navigation/src/nodes/usbl_simulator_main.cpp
  </files>
  <action>
    Implement UsblSimulatorNode with CRITICAL delayed timestamp behavior:

    **Constructor:**
    - Declare all parameters from config
    - Create subscriber to /truth/odometry
    - Create publishers for /usbl/position and /usbl/valid
    - Create timer at publish_rate (0.2Hz = every 5 seconds)
    - Initialize position buffer (ring buffer, size ~100 entries)
    - Store ship position from config

    **odometryCallback(msg):**
    - Extract position from odometry
    - Store (msg.header.stamp, position) in circular buffer
    - Buffer allows looking up historical positions

    **publishTimer() - CRITICAL LOGIC:**
    ```cpp
    // 1. Determine measurement time (NOT current time!)
    rclcpp::Time current_time = now();
    rclcpp::Time measurement_time = current_time - rclcpp::Duration::from_seconds(processing_delay_);

    // 2. Look up position at measurement_time from buffer
    Eigen::Vector3d auv_position;
    if (!getPositionAtTime(measurement_time, auv_position)) {
        RCLCPP_WARN(get_logger(), "No buffered position for USBL measurement");
        return;
    }

    // 3. Check for dropout
    if (uniform_dist_(rng_) < dropout_probability_) {
        std_msgs::msg::Bool valid_msg;
        valid_msg.data = false;
        valid_pub_->publish(valid_msg);
        RCLCPP_INFO(get_logger(), "USBL dropout");
        return;
    }

    // 4. Compute range and noise
    double range = (auv_position - ship_position_).norm();
    double noise_std = std::max(range_noise_percent_ * range, min_noise_);

    // 5. Add noise to position
    Eigen::Vector3d noisy_position = auv_position;
    noisy_position.x() += std::normal_distribution<double>(0, noise_std)(rng_);
    noisy_position.y() += std::normal_distribution<double>(0, noise_std)(rng_);
    noisy_position.z() += std::normal_distribution<double>(0, noise_std)(rng_);

    // 6. Inject outlier (5% probability)
    bool is_outlier = false;
    if (uniform_dist_(rng_) < outlier_probability_) {
        is_outlier = true;
        // Random direction offset
        Eigen::Vector3d offset = Eigen::Vector3d::Random().normalized() * outlier_offset_;
        noisy_position += offset;
        RCLCPP_WARN(get_logger(), "USBL outlier injected!");
    }

    // 7. Publish with MEASUREMENT timestamp (not current!)
    geometry_msgs::msg::PointStamped usbl_msg;
    usbl_msg.header.stamp = measurement_time;  // CRITICAL: delayed timestamp!
    usbl_msg.header.frame_id = "world";
    usbl_msg.point.x = noisy_position.x();
    usbl_msg.point.y = noisy_position.y();
    usbl_msg.point.z = noisy_position.z();
    position_pub_->publish(usbl_msg);

    std_msgs::msg::Bool valid_msg;
    valid_msg.data = true;
    valid_pub_->publish(valid_msg);

    RCLCPP_INFO(get_logger(),
                "USBL: pos=[%.2f, %.2f, %.2f], range=%.1fm, noise_std=%.3fm, outlier=%s, delay=%.2fs",
                noisy_position.x(), noisy_position.y(), noisy_position.z(),
                range, noise_std, is_outlier ? "YES" : "no", processing_delay_);
    ```

    **getPositionAtTime(time, position_out):**
    - Search buffer for closest entry to requested time
    - Linear interpolation between bracketing entries if needed
    - Return false if time is before buffer start

    **Logging:**
    - Log each USBL measurement with range, noise, outlier status
    - Log dropouts when they occur
    - Periodically log buffer size and age

    **Main file (usbl_simulator_main.cpp):**
    - Standard ROS2 main with spin
  </action>
  <verify>
    ros2 topic echo /usbl/position shows timestamps ~0.2s in the past
    ros2 topic hz /usbl/position shows ~0.2Hz
    Occasional "outlier injected" warnings in log
  </verify>
  <done>USBL publishes delayed position measurements with noise and outliers</done>
</task>

<task type="auto">
  <name>Task 3: Update CMakeLists.txt and launch file</name>
  <files>
    src/usbl_navigation/CMakeLists.txt
    src/usbl_navigation/launch/simulation.launch.py
  </files>
  <action>
    **CMakeLists.txt updates:**
    - Add usbl_simulator_node executable
    - Link against required libraries
    - Install target

    **launch/simulation.launch.py updates:**
    - Add usbl_simulator_node to launch
    - Load parameters from sensor_noise.yaml
    - output='screen' for visibility

    Now all 4 nodes launch together:
    - truth_generator_node
    - imu_simulator_node
    - dvl_simulator_node
    - usbl_simulator_node
  </action>
  <verify>
    colcon build --packages-select usbl_navigation succeeds
    ros2 launch usbl_navigation simulation.launch.py starts all 4 nodes
    ros2 topic list shows all expected topics:
      /truth/odometry, /truth/path
      /imu/data
      /dvl/twist, /dvl/bottom_lock
      /usbl/position, /usbl/valid
  </verify>
  <done>All sensor simulators launch together from single launch file</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] colcon build --packages-select usbl_navigation succeeds
- [ ] ros2 launch usbl_navigation simulation.launch.py runs all 4 nodes
- [ ] ros2 topic hz /usbl/position shows ~0.2Hz (every 5 seconds)
- [ ] USBL timestamps are in the PAST (verify with ros2 topic echo)
- [ ] USBL noise increases with range (check logs at different positions)
- [ ] Occasional outliers appear in logs (~5%)
- [ ] Occasional dropouts occur (~10%)
</verification>

<success_criteria>
- All tasks completed
- Package builds without errors
- USBL publishes at 0.2Hz with DELAYED timestamps
- Noise is range-dependent (2% of range, minimum 0.3m)
- 10% dropout probability working
- 5% outlier injection with 5m offset working
- All 4 sensor nodes launch together
</success_criteria>

<output>
After completion, create `.planning/phases/06-sensor-foundation/06-03-SUMMARY.md`
</output>
